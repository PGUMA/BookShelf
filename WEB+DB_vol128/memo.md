# 演習で慣れる！データベース

**三層スキーマ**

- 外部スキーマ
    外部で表示したり視認されるデータ構造のあり方(viewや結合結果)
- 概念スキーマ
    DB上での論理的なデータ構造のあり方（tableや関連）
- 内部スキーマ
    DBMS内部での物理的なデータ配置やあり方

# ゼロから学ぶTerraform

## IaCとは？

インフラをコードから何度でも再現可能なインスタンスとして扱えるようにするような思想や仕組み

人による運用を単に機械的に置き換えられるに留まらず、ソフトウェア工学の知恵をインフラの世界に活かすことができるようにした破壊的イノベーション

## Terraformとは？

IaC(Infrastructure As Code)としてアジリティの高いインフラ環境を整えるためのプロビジョニングを得意とするOSSツールでデファクトスタンダードと言っていいもの。マルチクラウドベンダーに対応しているため、属人化・局所最適を防げるメリットがある。

## Terraformの良い点

- コード自体が読みやすくコメントも挿入できてドキュメントとして高い質を保てる
- 学習コストが低い
- 手順ではなくあるべき状態を書くため宣言型で簡潔明瞭で複雑なことを意識しなくて良い

## Terraform基本コマンド

**init**

コード定義を読み込んでスタンバイする（スタンバイってなに？）

**plan**

実際に行われる操作計画を表示する

**apply**

実際のリソースの払い出しをする

**destory**

サーバーの削除をする

## Terraformのアーキテクチャー

**tfファイル**

クラウドのリソース構成を定義するファイル

**コア**

Terraformの本体でCLIを提供

**プロバイダ**

Coreから呼ばれる各種クラウドベンダーへのAPI操作を提供するラッパー

**tfstateファイル**

クラウドのリソース状態から現状をリバースしてファイル化したもの

## tfファイルの設計

**ルートモジュール（ワーキングディレクトリ）**

１つのインフラを複数のワーキングディレクトリに分けて管理する

**モジュール**

再利用可能な関数のようなもの

- モジュールを使うことでインフラ定義の重複をDRYに保てる
- 凝集性を高めて認知負荷を下げられる
- 可搬性が高まり、誰でも質の高いインフラスタックを利用できる
- スタック単位で実装の差し替えが可能（ex. IaaS to FaaS）

### ワーキングディレクトリ分割の思想（設計原則）

- 変更のライフサイクルを考慮して、影響範囲を検討、デプロイ単位を分割する
    - 変更頻度→頻度の高いリソースは切り出す価値あり
    - 重要→重要度の高いリソースは切り出す価値あり
- 組織構造に合わせて責任範囲を明確化する
    - 管理単位に合わせてリソースを切り出すと運用しやすい
- 保守性を向上（認知コストの低減・実行時間の削減　※部分的な冗長化とトレードオフ）
    
    ### デザインパターン（例）
    
    **プラットフォーム/コンピュート/データストア**
    
    - プラットフォーム
        - ネットワーク等のリソース基盤となるようなもので変更頻度低
    - コンピュート
        - アプリケーションの実行基盤でアジリティ重視、変更頻度高
    - データストア
        - 重要なデータ管理基盤、イミュータブル設計が難しく、変更頻度低

### モジュールの設計

コンポーネント指向を意識した設計

- 結合度
    - 意味のある単位でスタックを整理してパラメータの受け渡し等をモジュール内部で完全にカプセル化した状態を目指す
- テスタブル
    - ユースケース単位の単体テストが可能なように設計する
- ロジック
    - スタックそのものではなくてロジックの詳細を隠蔽してドキュメントとしての可読性を高める

ユースケースごとにモジュール分割をして、変数は依存関係の解決と可搬性の確保のために使う

つまり、モジュール名は具体的なユースケースとなるべき

### 環境差異の解決パターン

- tfvarsファイルを環境別に用意
    - ルートディレクトリを共有するため環境ごとのtsstateファイルも共有されてしまう
- workspace機能
    - workspaceの切り替えでtsstateファイルを切り替え可能になるが、環境ごとの変数をロジックとして切り替える複雑性が入り込み認知負荷が上がる
- 環境ごとにワーキングディレクトリを分ける
    - tfvarsは本来シークレット情報等を切り出すためにある
    
### 蛇足

<u>ブランチ戦略</u>

    1. Git Flow
    2. GitHub Flow
    3. GitLab Flow

# エンジニアのための英語

## commit logの書き方

### commit区分

- 修正

    `fix`

    > fix (for) ~

- 追加

    `add`

    > add ~

- 削除

    `remove/delete`

    > remove/delete ~

- リファクタリング

    `refactor`

    > refactor ~

- 移動

    `move`

    > move ~ to/in ~

- 変更

    `change`

    > change ~ to/for ~

- 改善

    `improve`

    > improve ~

#### 内容表現

- 〜にする

    `make`

    > make ~ ~

- 使う

    `use`

    > use ~

- 許容

    `allow`

    > allow ~

- しない

    `don't`

    > don't ~

# コンポーネント駆動開発

ページベース開発→コンポーネント駆動開発（CDD）

**コンポーネントとは？**

    UIを構築するモジュラーな部品

**コンポーネント駆動開発**

    近年の複雑化するアプリケーションUIへの要求に対して高い凝集性/低い結合度を保ち保守性を高めるための開発アプローチ
    ※UIをモジュール化して汎用性を高めて適切に再利用できる環境が必要

## サポートツール

UIコンポーネントエクスプローラー

デファクトスタンダード = Stroybook

**Stroyとは**

    Stroybookに登録したコンポーネントに対して、特定状態を与えたもの

### 環境構築

[参考](https://storybook.js.org/docs/react/get-started/install)
```
npx create-react-app sb-ts-react-playground --template typescript
cd <app-name>
npx -p @storybook/cli sb init --use-npm
npm run storybook
```

> ※2020/04/27時点でnode@18には対応できていない[^1]模様(node@17.9.0)にて起動確認

[^1]: https://github.com/storybookjs/storybook/issues/18010


### 機能

**CSF3.0**

※2021/11~の新機能

- title設定がデフォルトで自動付与されるように
    - プロジェクト内の命名規則が統一される
    - ディレクトリ配置の変更が自動で追従される
- object形式でexport可能に
- 上記objectを分割代入形式で再利用可能に

- play function
    - ユーザー操作をコード化して、操作によってのみ到達可能な状態をStorybook上で表現できる
    - テストコードとして再利用可能（ex Jestと連携）

[参考URL](https://github.com/takefumi-yoshii/wdb-frontendcsf-play-example)